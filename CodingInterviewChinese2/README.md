# 剑指Offer（第2版） #

https://leetcode-cn.com/problemset/lcof/

https://www.nowcoder.com/ta/coding-interviews

## 链表 ##

**剑指 Offer 06. 从尾到头打印链表** //简单，栈，递归

**剑指 Offer 24. 反转链表** //206，简单，递归

**剑指 Offer 18. 删除链表的结点** //203（删除所有）

1.在O(1)时间内删除链表结点 //无，只删除指定的一个

> 2.删除链表中重复的结点 //无

**剑指 Offer 22. 链表中倒数第k个结点** // 简单，双指针

**剑指 Offer 23. 链表中环的入口结点**（JZ55 链表中环的入口结点）//无

**剑指 Offer 52. 两个链表的第一个公共结点** //160，简单

**剑指 Offer 25. 合并两个排序的链表** //21，简单，递归

**剑指 Offer 35. 复杂链表的复制** //138，中等

## 二叉树 ##

**剑指 Offer 07. 重建二叉树** //105，中等，DFS，递归

**剑指 Offer 37. 序列化二叉树** //297，困难，设计

**剑指 Offer 08. 二叉树的下一个结点**(JZ57 二叉树的下一个结点) //无

**剑指 Offer 26. 数的子结构** //中等，递归

**剑指 Offer 27. 二叉树的镜像** //226，简单，递归

**剑指 Offer 28. 对称的二叉树** //101，简单，递归

**剑指 Offer 32. 从上到下打印二叉树** //中等，BFS, 递归

1.不分行从上往下打印二叉树 //队列

2.分行从上到下打印二叉树 //102，队列

3.之字形打印二叉树 //栈

**剑指 Offer 34. 二叉树中和为某一值的路径** //113，中等，DFS，递归

**剑指 Offer 55. 二叉树的深度**

1.二叉树的深度 //104，简单，DFS

2.平衡二叉树 //110，简单，DFS

**剑指 Offer 68 - II. 二叉树的最近公共祖先** //236，中等，DFS

## 二叉搜索树 ##

**剑指 Offer 33. 二叉搜索树的后序遍历序列** //中等

**剑指 Offer 36. 二叉搜索树与双向链表** //426，中等，分治算法

**剑指 Offer 54. 二叉搜索树的第k大结点** //简单

**剑指 Offer 68 - I. 二叉搜索树的最近公共祖先** //235，简单

## 栈/队列 ##

**剑指 Offer 09. 用两个栈实现队列** //简单，设计

**剑指 Offer 30. 包含min函数的栈** //155，简单，设计

**剑指 Offer 31. 栈的压入、弹出序列** //946，中等

**剑指 Offer 59 - I. 滑动窗口的最大值** //239，困难

**剑指 Offer 59 - II. 队列的最大值** //中等

## 堆 ##

**剑指 Offer 40. 最小的k个数** //215，快速排序

**剑指 Offer 41. 数据流中的中位数** //295，堆，设计

## 哈希表 ##

**剑指 Offer 50. 第一个只出现一次的字符**

**50_02. 字符流中第一个只出现一次的字符** //无

## 图 回溯法 ##

**剑指 Offer 12. 矩阵中的路径** //79

**剑指 Offer 13. 机器人的运动范围**

**剑指 Offer 38. 字符串的排列**

## 递归 ##

**剑指 Offer 10- I. 斐波那契数列** //509

**剑指 Offer 10- II. 青蛙跳台阶问题** //70

## 查找 ##

**剑指 Offer 03. 数组中重复的数字**

1.找出数组中重复的数字

> 2.不修改数组找出重复的数字 //无，二分查找

**剑指 Offer 04. 二维数组中的查找** //240

**剑指 Offer 11. 旋转数组的最小数字** //154，二分查找

**剑指 Offer 53 - I. 在排序数组中查找数字 I** //34，二分查找

**剑指 Offer 53 - II. 0～n-1中缺失的数字** //二分查找

**面试题53（三）：数组中数值和下标相等的元素** //二分查找

## 双指针 ##

**剑指 Offer 21. 调整数组顺序使奇数位于偶数前面** //双指针

**剑指 Offer 57. 和为s的两个数字** //双指针

**剑指 Offer 57 - II. 和为s的连续正数序列** //双指针

## 动态规划与贪婪算法 ##

**剑指 Offer 42. 连续子数组的最大和** //53，分治算法，动态规划

> **剑指 Offer 19. 正则表达式匹配** //10，动态规划

**剑指 Offer 48. 最长不含重复字符的子字符串** //3，动态规划

**剑指 Offer 63. 股票的最大利润** //121，动态规划

**剑指 Offer 14- I. 剪绳子** //343，数学，动态规划

**剑指 Offer 47. 礼物的最大价值** //动态规划

**剑指 Offer 60. n个骰子的点数** //动态规划

**剑指 Offer 62. 圆圈中最后剩下的数字**

## 排序 ##

> **剑指 Offer 51. 数组中的逆序对**

**剑指 Offer 45. 把数组排成最小的数** //数组

**剑指 Offer 61. 扑克牌中的顺子**

## 位运算 ##

**剑指 Offer 15. 二进制中1的个数** //191

**剑指 Offer 16. 数值的整数次方** //50，递归

**剑指 Offer 65. 不用加减乘除做加法**

**剑指 Offer 56 - I. 数组中数字出现的次数** //数组

**剑指 Offer 56 - II. 数组中数字出现的次数 II** //数组

## 数组 ##

**剑指 Offer 66. 构建乘积数组**

**剑指 Offer 29. 顺时针打印矩阵** //54

**剑指 Offer 39. 数组中出现次数超过一半的数字** //169

## 字符串 ##

**剑指 Offer 05. 替换空格**

> **剑指 Offer 20. 表示数值的字符串**

**剑指 Offer 58 - I. 翻转单词顺序** //151，中等

**剑指 Offer 58 - II. 左旋转字符串**

**剑指 Offer 67. 把字符串转换成整数** //8，数学

## 其他 ##

**剑指 Offer 64. 求1+2+…+n** //逻辑运算符 短路

>**剑指 Offer 46. 把数字翻译成字符串**

## 数学 ##

>**剑指 Offer 17. 打印从1到最大的n位数**

**剑指 Offer 43. 1～n整数中1出现的次数** //233

**剑指 Offer 44. 数字序列中某一位的数字** //400

**剑指 Offer 49. 丑数** //264


----------

    int binarySearch(const int* nums, int low, int high, int target) {
      while (low <= high) {
        int mid = low + (high - low)/2;
        if (nums[mid] < target) {
          low = mid + 1;
        } else if (nums[mid] > target) {
          high = mid - 1;
        } else {
          return mid;
        }
      }
    
      return -1;
    }


----------

    //qsort partition
    int partition(std::vector<int>& nums, int left, int right) {
      int pivot = nums[left];
      int l = left + 1, r = right;
      while (l <= r) {
        if (nums[l] > pivot && nums[r] < pivot) {
          std::swap(nums[l++], nums[r--]);
        }
        if (nums[l] <= pivot) {
          l++;
        }
        if (nums[r] >= pivot) {
          r--;
        }
      }
      std::swap(nums[left], nums[r]);
      return r;
    }
  
    void quickSort(std::vector<int>& nums, int left, int right) {
      if (left >= right) {
        return;
      }
      int pos = partition(nums, left, right);
      quickSort(nums, left, pos - 1);
      quickSort(nums, pos + 1, right);
    }

----------

